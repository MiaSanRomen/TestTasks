using RegulatorApplication.Library.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace RegulatorApplication.Library.Interfaces
{
    public class Regulator : IRegulator
    {
        private decimal _load;
        private decimal _estimatedLoad;
        private int _budget;
        private int _interval;
        // those collections are not suitable for concurrent access - use ConcurrentQueue, ConcurrentDictionary or other concurrent collection OR use locks - but locks are slow so Concurrent collections are better solution
        private ICollection<Request> _currentRequests;
        private ICollection<Request> _commitedRequests;

        //Property for OnLoadChanged event invoking
        private decimal Load
        {
            get
            {
                return _load;
            }
            set
            {
                _load = value;
                OnLoadChanged?.Invoke(this, GetLoad());
            }
        }
        //List of messages to validate OnLoadChanged event properly work
        public ICollection<string> LogMessages { get; private set; }
        public EventHandler<decimal> OnLoadChanged { get; set; }

        // it is better to use interface as settings, because you can use dependency injection - i propose to create an interface for the settings and give it as parameter to contructor
        public Regulator(int budget, int interval)
        {
            _budget = budget;
            _interval = interval;
            _currentRequests = new List<Request>();
            _commitedRequests = new List<Request>();
            LogMessages = new List<string>();
            // this is incorrect way how to register event, you should use += operator, because otherwise you rewrite already existing events (not our situation, but the approach is important);
            // also when you register event, you should not use anonymous function, but rather use some private function, because you need to unregister the event when this object is destroyed - this implies that regulator should implement IDisposable and in dispose method should be un-registration of the event (using -= operator)
            OnLoadChanged = (object? sender, decimal load) =>
            {
                var index = LogMessages.Count() + 1;
                string logMessage = $"{index} - Current load: {load}";
                LogMessages.Add(logMessage);
            };
        }

        public void Commit()
        {
            foreach(var request in _currentRequests)
            {
                // here are multiple enumerations of the collection which is very inefficient
                if(!_commitedRequests.Contains(request) && _commitedRequests.Count() < _budget)
                {
                    _commitedRequests.Add(request);
                    request.Processed += OnRequestProcessed;
                    request.Commit(_interval);
                }
            }

            UpdateLoad();
        }

        public decimal GetEstimatedLoad()
        {
            return _estimatedLoad;
        }

        public decimal GetLoad()
        {
            return Load;
        }

        public void Ignore(Request request)
        {
            if (request != null && _currentRequests.Contains(request))
            {
                _currentRequests.Remove(request);
                _commitedRequests.Remove(request);
                UpdateEstimatedLoad();
                UpdateLoad();
            }
        }

        public void Propose(Request request)
        {
            _currentRequests.Add(request);
            UpdateEstimatedLoad();
        }

        public void Rollback()
        {
            // this is very inefficient - it is generated by not suitable choice of the collections - also would be much more efficient to use one collection for un-committed and another for committed requests - with no overlaps - then the rollback would be just clear of one collection
            var requestsToRemove = new List<Request>(_currentRequests);
            foreach (var request in requestsToRemove)
            {
                if (!_commitedRequests.Contains(request))
                {
                    _currentRequests.Remove(request);
                }
            }

            UpdateEstimatedLoad();
        }

        private void OnRequestProcessed(object? sender, EventArgs e)
        {
            // here should be event un-registration - otherwise there will be a lot of unregistered events on all the requests
            var request = (Request)sender;
            
            // also the functionality wasnt understand properly, the regulator should regulate the requests for some interval regardless the requests are finished or unfinished
            _commitedRequests.Remove(request);
            _currentRequests.Remove(request);
            UpdateEstimatedLoad();
            UpdateLoad();
        }

        private void UpdateEstimatedLoad()
        {
            // this is very inefficient - enumeration is not neccessary if you handle the events, propose, commit and rollback correctly - you can compute the number of requests each time you Add (+1) or Remove (-1) - then you do not have to calculate the count, which is expensive operation
            _estimatedLoad = Convert.ToDecimal(_currentRequests.Count()) / Convert.ToDecimal(_budget);
        }

        private void UpdateLoad()
        {
            // this is very inefficient - enumeration is not neccessary if you handle the events, propose, commit and rollback correctly - you can compute the number of requests each time you Add  (+1) or Remove (-1) - then you do not have to calculate the count, which is expensive operation
            Load = Convert.ToDecimal(_commitedRequests.Count()) / Convert.ToDecimal(_budget);
        }
    }
}
